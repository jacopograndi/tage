use std::{
    collections::HashMap,
    net::{SocketAddr, UdpSocket},
    time::{Duration, SystemTime},
};

use bincode::config::Configuration;
use renet::{
    transport::{
        ClientAuthentication, NetcodeClientTransport, NetcodeServerTransport, ServerAuthentication,
        ServerConfig,
    },
    ClientId, ConnectionConfig, DefaultChannel, RenetClient, RenetServer, ServerEvent,
};
use tage_core::{
    actions::PlayerAction,
    game::{BoardView, MapSettings},
};
use tracing::{error, info};

use crate::Member;

// Default ip port that the server listens from
pub const PORT: u16 = 45557;

// Game unique identifier, randomly generated by my head
pub const PROTOCOL_ID: u64 = 4555706555;

// Static id of the host
pub const HOST_CLIENT_ID: ClientId = ClientId::from_raw(1);

/// Sugar macro, client id is just a number
#[macro_export]
macro_rules! raw {
    ($num: expr) => {
        ClientId::from_raw($num)
    };
}

pub struct Net {
    pub connection: Option<Connection>,
    pub error: Vec<String>,
}

impl Net {
    pub fn new() -> Self {
        Self {
            connection: None,
            error: vec![],
        }
    }

    pub fn is_client(&self) -> bool {
        match &self.connection {
            Some(Connection::Client(_)) => true,
            _ => false,
        }
    }

    pub fn is_server(&self) -> bool {
        match &self.connection {
            Some(Connection::Server(_)) => true,
            _ => false,
        }
    }

    pub fn get_members(&self) -> HashMap<ClientId, Member> {
        match &self.connection {
            Some(Connection::Client(client)) => client.members.clone(),
            Some(Connection::Server(server)) => server.members.clone(),
            None => HashMap::new(),
        }
    }

    pub fn get_local_id(&self) -> Option<ClientId> {
        match &self.connection {
            Some(Connection::Client(client)) => client.get_local_id(),
            Some(Connection::Server(server)) => server.get_local_id(),
            None => None,
        }
    }

    pub fn open_client(&mut self, member: Member, server_address: SocketAddr) {
        self.connection = Some(Connection::Client(Client::new(member, server_address)))
    }

    pub fn open_server(&mut self, member: Member) {
        self.connection = Some(Connection::Server(Server::new(member)))
    }

    pub fn update(&mut self, duration: Duration) {
        let result = match &mut self.connection {
            Some(Connection::Client(client)) => client.update(duration),
            Some(Connection::Server(server)) => server.update(duration),
            None => Ok(()),
        };
        if let Err(error) = result {
            self.error.push(error);
            self.connection = None;
        }
    }

    pub fn kick(&mut self, client_id: ClientId) {
        match &mut self.connection {
            Some(Connection::Server(server)) => server.server.disconnect(client_id),
            _ => {}
        }
    }

    pub fn client_send(&mut self, message: &ClientMessages) {
        match &mut self.connection {
            Some(Connection::Client(client)) => {
                client.client.send_message(
                    DefaultChannel::ReliableOrdered,
                    bincode::encode_to_vec::<&ClientMessages, Configuration>(
                        message,
                        Configuration::default(),
                    )
                    .unwrap(),
                );
            }
            _ => {}
        }
    }

    pub fn server_send(&mut self, message: &ServerMessages) {
        match &mut self.connection {
            Some(Connection::Server(server)) => {
                server.server.broadcast_message(
                    DefaultChannel::ReliableOrdered,
                    bincode::encode_to_vec::<&ServerMessages, Configuration>(
                        message,
                        Configuration::default(),
                    )
                    .unwrap(),
                );
            }
            _ => {}
        }
    }

    pub fn server_send_at(&mut self, client_id: ClientId, message: &ServerMessages) {
        match &mut self.connection {
            Some(Connection::Server(server)) => {
                server.server.send_message(
                    client_id,
                    DefaultChannel::ReliableOrdered,
                    bincode::encode_to_vec::<&ServerMessages, Configuration>(
                        message,
                        Configuration::default(),
                    )
                    .unwrap(),
                );
            }
            _ => {}
        }
    }

    pub fn close_connection(&mut self) {
        match self.connection.take() {
            Some(Connection::Client(mut client)) => client.client.disconnect(),
            Some(Connection::Server(mut server)) => server.server.disconnect_all(),
            None => {}
        }
    }
}

pub enum Connection {
    Client(Client),
    Server(Server),
}

pub struct Server {
    pub server: RenetServer,
    pub transport: NetcodeServerTransport,
    pub members: HashMap<ClientId, Member>,
    pub queue: Vec<(ClientId, ClientMessages)>,
    pub connection_queue: Vec<ServerConnectionMessages>,
}

#[allow(dead_code)]
pub enum ServerConnectionMessages {
    Connected(ClientId),
    Disconnected(ClientId),
}

/// From server to client
#[derive(Debug, bincode::Encode, bincode::Decode)]
pub enum ServerMessages {
    ClientConnected { client_id: u64, member: Member },
    ClientDisconnected { client_id: u64 },
    MapSettings { map_settings: MapSettings },
    Board { board: BoardView },
    ToGame,
    ToLobby,
}

/// From client to server
#[derive(Debug, bincode::Encode, bincode::Decode)]
pub enum ClientMessages {
    MemberChange { member: Member },
    PlayerAction { action: PlayerAction },
    Undo,
}

impl Server {
    pub fn new(member: Member) -> Self {
        let socket = UdpSocket::bind(format!("0.0.0.0:{}", PORT)).unwrap();
        let current_time = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap();
        let server_config = ServerConfig {
            current_time,
            max_clients: 256,
            protocol_id: PROTOCOL_ID,
            public_addresses: vec![socket.local_addr().unwrap()],
            authentication: ServerAuthentication::Unsecure,
        };
        let transport = NetcodeServerTransport::new(server_config, socket).unwrap();
        let server = RenetServer::new(ConnectionConfig::default());
        info!(target: "server", "opened");
        Self {
            server,
            transport,
            members: [(HOST_CLIENT_ID, member)].into_iter().collect(),
            queue: vec![],
            connection_queue: vec![],
        }
    }

    pub fn get_local_id(&self) -> Option<ClientId> {
        Some(HOST_CLIENT_ID)
    }

    pub fn update(&mut self, duration: Duration) -> Result<(), String> {
        self.server.update(duration);
        if let Err(e) = self.transport.update(duration, &mut self.server) {
            error!(target: "server", "{}", e);
            return Err(e.to_string());
        }

        while let Some(event) = self.server.get_event() {
            match event {
                ServerEvent::ClientConnected { client_id } => {
                    for (id, member) in self.members.iter() {
                        self.server.send_message(
                            client_id,
                            DefaultChannel::ReliableOrdered,
                            bincode::encode_to_vec::<ServerMessages, Configuration>(
                                ServerMessages::ClientConnected {
                                    client_id: id.raw(),
                                    member: member.clone(),
                                },
                                Configuration::default(),
                            )
                            .unwrap(),
                        );
                    }

                    let user_data = self.transport.user_data(client_id).unwrap();
                    let member = Member::from_user_data(&user_data);
                    self.members.insert(client_id, member.clone());
                    self.server.broadcast_message(
                        DefaultChannel::ReliableOrdered,
                        bincode::encode_to_vec::<ServerMessages, Configuration>(
                            ServerMessages::ClientConnected {
                                client_id: client_id.raw(),
                                member,
                            },
                            Configuration::default(),
                        )
                        .unwrap(),
                    );

                    self.connection_queue
                        .push(ServerConnectionMessages::Connected(client_id))
                }
                ServerEvent::ClientDisconnected { client_id, .. } => {
                    self.members.remove(&client_id);
                    self.server.broadcast_message(
                        DefaultChannel::ReliableOrdered,
                        bincode::encode_to_vec::<ServerMessages, Configuration>(
                            ServerMessages::ClientDisconnected {
                                client_id: client_id.raw(),
                            },
                            Configuration::default(),
                        )
                        .unwrap(),
                    );

                    self.connection_queue
                        .push(ServerConnectionMessages::Disconnected(client_id))

                    //todo: show reason why to ui
                }
            }
        }

        for client_id in self.server.clients_id() {
            while let Some(message) = self
                .server
                .receive_message(client_id, DefaultChannel::ReliableOrdered)
            {
                let result = bincode::decode_from_slice::<ClientMessages, Configuration>(
                    &message,
                    Configuration::default(),
                );
                match result {
                    Ok((message, _)) => {
                        info!(
                            target: "server", "received from client({}): {:?}",
                            client_id, message
                        );
                        match &message {
                            ClientMessages::MemberChange { member } => {
                                self.members.insert(client_id, member.clone());
                            }
                            _ => {}
                        }
                        self.queue.push((client_id, message));
                    }
                    Err(e) => {
                        error!(
                            target: "server",
                            "error: {}, received from client {} an invalid message: {:?}",
                            e, client_id, message
                        );
                    }
                }
            }
        }

        self.transport.send_packets(&mut self.server);

        Ok(())
    }
}

pub struct Client {
    pub client: RenetClient,
    pub transport: NetcodeClientTransport,
    pub members: HashMap<ClientId, Member>,
    pub queue: Vec<ServerMessages>,
}

impl Client {
    pub fn new(member: Member, server_address: SocketAddr) -> Self {
        let connection_config = ConnectionConfig::default();
        let client = RenetClient::new(connection_config);

        let socket = UdpSocket::bind("127.0.0.1:0").unwrap();
        let current_time = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap();
        let client_id = current_time.as_millis() as u64;
        //todo: add the username hash too?
        let authentication = ClientAuthentication::Unsecure {
            server_addr: server_address,
            client_id,
            user_data: Some(member.to_user_data()),
            protocol_id: PROTOCOL_ID,
        };
        let transport = NetcodeClientTransport::new(current_time, authentication, socket).unwrap();
        info!(target: "client", "opened");
        Client {
            client,
            transport,
            members: [(raw!(client_id), member)].into_iter().collect(),
            queue: vec![],
        }
    }

    pub fn get_local_id(&self) -> Option<ClientId> {
        Some(self.transport.client_id())
    }

    pub fn update(&mut self, duration: Duration) -> Result<(), String> {
        self.client.update(duration);
        if let Err(e) = self.transport.update(duration, &mut self.client) {
            error!(target: "client", "{}", e);
            return Err(e.to_string());
        }

        if let Some(e) = self.client.disconnect_reason() {
            error!(target: "client", "{}", e);
            return Err(e.to_string());
        }

        while let Some(message) = self.client.receive_message(DefaultChannel::ReliableOrdered) {
            let result = bincode::decode_from_slice::<ServerMessages, Configuration>(
                &message,
                Configuration::default(),
            );
            match result {
                Ok((message, _)) => {
                    info!(target: "client", "received from server: {:?}", message);
                    match &message {
                        ServerMessages::ClientConnected { client_id, member } => {
                            self.members.insert(raw!(*client_id), member.clone());
                        }
                        ServerMessages::ClientDisconnected { client_id } => {
                            self.members.remove(&raw!(*client_id));
                        }
                        _ => self.queue.push(message),
                    }
                }
                Err(e) => {
                    error!(
                        target: "client",
                        "error: {}, received from server an invalid message: {:?}",
                        e, message
                    );
                }
            }
        }

        if let Err(e) = self.transport.send_packets(&mut self.client) {
            error!(target: "client", "{}", e);
            return Err(e.to_string());
        }

        Ok(())
    }
}
